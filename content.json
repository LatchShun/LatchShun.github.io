{"meta":{"title":"Latch轨迹","subtitle":null,"description":"高并发,大数据,微服务","author":"修巴利耶","url":"http://latchshun.github.io","root":"/"},"pages":[],"posts":[{"title":"动态修改注解值","slug":"动态修改注解值","date":"2019-09-25T14:17:00.000Z","updated":"2019-10-20T14:53:06.376Z","comments":true,"path":"2019/09/25/动态修改注解值/","link":"","permalink":"http://latchshun.github.io/2019/09/25/动态修改注解值/","excerpt":"","text":"背景平时开发业务时，由于特殊需要，使得一份代码需要部署到4个应用服务中为不同对象进行服务。公司使用的配置中心是自研发的，暂不支持配置中心注解（如：@DynamicPropertyInject(name = &quot;${application.effective.exchanges}&quot;)）的值采用properties文件来动态配置。这使得在同套代码的不同应用场景下，表明同个含义的注入就需要声明多次，且有且仅只有一个声明对于当前应用是有效的。从简洁的角度来说不适合。 示例注解： 123456@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.FIELD&#125;public @interface DynamicPropertyInject &#123; String name() default '';&#125; 不能依据properties注入的代码情形： 12345678910public class DynamicConfiguration &#123; @DynamicPropertyInject(name = \"application1.effective.name\") private String application1ExchangeName; @DynamicPropertyInject(name = \"application2.effective.name\") private String application2ExchageName; @DynamicPropertyInject(name = \"application3.effective.name\") private String application3ExchangeName;&#125; 其实在每个应用中，仅只有application1ExchangeName或application2ExchangeName或application3ExchangeName其中之一有效。 能依据properties注入的代码情形： 1234public class DynamicConfiguration &#123; @DynamicPropertyInject(name = \"$&#123;application.effective.name&#125;\") private String applicationExchangeName;&#125; 解决：针对如上所述的场景，其实要解决的是来获取applicationExchangeName的时候，需要根据当前的应用名称来取其对应的值。很自然的，第一反应是通过反射来获取注解属性的值并修改之。 在这里提供下思路： 为DynamicConfiguration的类定义切面； 程序执行到注解DynamicPropertyInject时，判断是否需要去修改值。是则修改，否则跳过。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class DynamicConfigValueAspect &#123; public static final String CHARACTER_DOLLAR = \"$\"; public static final String CHARACTER_NUMBERSIGN = \"#\"; @Autowired private ApplicationProperties applicationProperties; @Around(\"this(package of DynamicConfiguration)\") public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; String methodName = pjp.getSignature().getName(); if (methodName.startsWith(\"get\") &amp;&amp; methodName.length() &gt;= 4) &#123; //提取属性名 String fieldName = methodName.substring(3, 4).toLowerCase() + methodName.substring(4); Field field = pjp.getTarget().getClass().getDeclaredField(fieldName); DynamicPropertyInject configuration = field.getAnnotation(DynamicPropertyInject.class); String configName = configuration.name(); //属性的DynamicPropertyInject注解值是否需要修改 if (StringUtils.isNotBlank(configName) &amp;&amp; StringUtils.startsWith(configName, CHARACTER_DOLLAR) || StringUtils.startsWith(configName, CHARACTER_NUMBERSIGN)) &#123; InvocationHandler invocationHandler = Proxy.getInvocationHandler(configuration); Field declaredField = invocationHandler.getClass().getDeclaredField(\"memberValues\"); declaredField.setAccessible(true); Map memberValues = (Map) declaredField.get(invocationHandler); //获取修改的值并修改 memberValues.put(\"name\", getApplicationPropertiesByConfigElement(configName)); &#125; &#125; return pjp.proceed(); &#125; //获取修改的值 private String getApplicationPropertiesByConfigElement(String configName) throws IllegalAccessException &#123; Field[] fields = ApplicationProperties.class.getDeclaredFields(); if (ArrayUtils.isEmpty(fields)) &#123; return null; &#125; for (Field field : fields) &#123; Value annotation = field.getAnnotation(Value.class); if (Objects.nonNull(annotation) &amp;&amp; StringUtils.equals(configName, annotation.value())) &#123; field.setAccessible(true); return String.valueOf(field.get(applicationProperties)); &#125; &#125; return null; &#125;&#125;//application property@Configurationpublic class ApplicationProperties &#123; @Value(\"$&#123;application.effective.name&#125;\") private String applicationEffectiveName;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://latchshun.github.io/tags/Java/"},{"name":"反射","slug":"反射","permalink":"http://latchshun.github.io/tags/反射/"},{"name":"注解","slug":"注解","permalink":"http://latchshun.github.io/tags/注解/"},{"name":"AOP","slug":"AOP","permalink":"http://latchshun.github.io/tags/AOP/"}]},{"title":"Redis Lua scripts debugger使用","slug":"redis_lua_debugger","date":"2019-09-11T11:50:00.000Z","updated":"2019-09-11T12:02:45.196Z","comments":true,"path":"2019/09/11/redis_lua_debugger/","link":"","permalink":"http://latchshun.github.io/2019/09/11/redis_lua_debugger/","excerpt":"","text":"背景说明使用Redis开发分布式应用时，难免会遇到需要使用分布式锁来确保某一小段逻辑的原子性操作，如：当存在某个key对应的值A大于值B时，则返回false；否则A + 1。试想一下，如果用到分布式锁，是不是有点感觉像是杀鸡用宰牛刀？ 由于Redis的操作都是原子性的，所以我们可以将如上所述的类似逻辑采用Lua脚本表述作为一个原子任务向redisClient提交，可以避免采用分布式锁。如脚本: 123456789101112131415161718192021local key = KEYS[1]local expire_time = tonumber(ARGV[1])local max_count = tonumber(ARGV[2])-- 验证key是否存在，不存在设置过期时间local is_key_exists = redis.call(\"EXISTS\", key)-- 存在if is_key_exists == 1 then local key_count = redis.call(\"get\", key) if tonumber(key_count) &gt;= max_count then return false; else redis.call(\"incr\", key) return true; endelse redis.call(\"incr\", key); redis.call(\"expire\", key, expire_time) return true;end 但此时发现，在Redis中调试是个困难的事情。但幸好，从Redis 3,2版本开始，提供了Lua script debugger来解决此问题。 Redis Lua调试器特点Redis Lua调试器代号为LDB，特点如下： 支持单步调试 支持静态和动态断点 支持将被调试的脚本载入至调试终端 支持对Lua变量进行观察 支持追踪脚本执行的Redis命令 支持以美观方式打印Redis值及Lua值 能够在无线循环及长时间执行步骤中模拟出断点 采用CS模型，S即Redis服务器，C即redis-cli客户端 默认情况下，每个调试会话都是fork子进程进行的。所以调试过程中不会影响Redis其他操作；调试结束后，本次会话中的内容都会被回滚 你也可以将调试会话设置成同步模式，但是此时必须注意调试时会影响Redis所有其他的操作，且调试会话产生的结果都会被保存下来 Redis Lua调试器快速入门想看视频的直接点这里，这是Redis之父录制的视频。 想看文字的继续。以我们在刚开始提供的Lua脚本，假设其目录为~/Desktop/tmp/test.lua。此时执行命令（需要先cd到redis-cli命令目录下）： 12345-- async moderedis-cli --ldb --eval redis_lua_file redis_key , param1 param2-- sync moderedis-cli --ldb-sync-mode --eval redis_lua_file redis_key , param1 param2 123456789 ~  redis-cli --ldb --eval ~/Desktop/tmp/test.lua key , 1 3Lua debugging session started, please use:quit -- End the session.restart -- Restart the script in debug mode again.help -- Show Lua script debugging commands.* Stopped at 6, stop reason = step over-&gt; 6 local key = KEYS[1]lua debugger&gt; 注意：redis-cli里的逗号前后都是有空格的。我这里示例是本地有开启redis-server，如果没有开启也可以连接到远程redis server进行调试。另外，key表示的是要传入脚本中处理的redis key，其后的1和3则是参数，中间用空格隔开。 之后所要做的就是在debugger里输入s命令回车，表示执行下一步，直至程序结束或有异常退出为止。 Redis Lua debug命令括号中字母代表命令缩写。 参考文章 Redis Lua scripts debugger","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://latchshun.github.io/tags/Redis/"},{"name":"Redis Lua scripts debugger","slug":"Redis-Lua-scripts-debugger","permalink":"http://latchshun.github.io/tags/Redis-Lua-scripts-debugger/"}]},{"title":"微服务基础架构图谱","slug":"微服务基础架构图谱","date":"2019-08-07T07:25:49.000Z","updated":"2019-08-07T09:12:21.893Z","comments":true,"path":"2019/08/07/微服务基础架构图谱/","link":"","permalink":"http://latchshun.github.io/2019/08/07/微服务基础架构图谱/","excerpt":"","text":"","categories":[],"tags":[{"name":"技术图谱","slug":"技术图谱","permalink":"http://latchshun.github.io/tags/技术图谱/"},{"name":"微服务","slug":"微服务","permalink":"http://latchshun.github.io/tags/微服务/"}]}]}