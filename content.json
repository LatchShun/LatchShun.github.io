{"meta":{"title":"Latch轨迹","subtitle":null,"description":"高并发,大数据,微服务","author":"修巴利耶","url":"http://latchshun.github.io","root":"/"},"pages":[],"posts":[{"title":"大表加索引方案","slug":"大表加索引方案","date":"2020-06-28T15:40:00.000Z","updated":"2020-06-28T16:57:35.810Z","comments":true,"path":"2020/06/28/大表加索引方案/","link":"","permalink":"http://latchshun.github.io/2020/06/28/大表加索引方案/","excerpt":"","text":"背景每个公司针对数据库的设计都有套方案。最近在巡检表的设计，发现之前有张表漏掉了针对更新时间字段updated_at的索引，现在需要加上该索引。 我们都知道，为表增加索引是会对表进行加锁处理的。稍有不慎，可能会导致表被锁后，业务无法进行读写操作而产生事故影响，通常都是报错Waiting for meta data lock。在对表进行修改时，特别是生产上，我们首先要观察对应的表此时是否在高并发读写（选择操作时机）、表的量级信息。 方案整体思路是： 先创建一张表，结构和原表相同； 在新表上添加索引； rename新表为原表的表名，原表换新的名称； 为原表新增索引； 待索引创建成功后，rename原表为原来的名称，并将新表里的数据导入到原表中 SQL可参考： 1234567891011121314151617-- 假设需要添加索引的表为`fea_moni_res`-- 1. 新建与表`fea_moni_res`同结构的表CREATE TABLE fea_moni_res_tmp LIKE fea_moni_res;-- 2. 新表上添加索引ALTER TABLE fea_moni_res_tmp ADD INDEX idx_index_name (col_name);-- 3. *rename*新表为原表的表名，原表换新的名称RENAME TABLE fea_moni_res TO fea_moni_res_1, fea_moni_res_tmp TO fea_moni_res;-- 4. 为原表新增索引，此步耗时较长ALTER TABLE fea_moni_res_1 ADD INDEX idx_index_name (col_name);-- 5. 待索引创建成功后，rename原表为原来的名称，并将新表里的数据导入到原表中RENAME TABLE fea_moni_res TO fea_moni_res_tmp, fea_moni_res_1 TO fea_moni_res;-- 需要根据业务来确定如果导入数据INSERT INTO fea_moni_res(col_name1, col_name2) SELECT col_name1, col_name2 FROM fea_moni_res_tmp; 总结本文提供了一种为大表添加索引的方法。当然，此方案不是完美的。譬如，步骤3中的rename操作后，是极有可能会对业务产生影响的，因为业务需要根据历史数据来判断逻辑。此时可能不得不在步骤2之后，先行将原表中的数据导入到新表中，待完全导入后再直接切表操作。此需要根据业务的场景来判断，具体问题具体分析。 此处只是提供了一种方案，涉及到为大表添加字段、删除字段的表锁操作均可参考。","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://latchshun.github.io/tags/MySQL/"},{"name":"索引","slug":"索引","permalink":"http://latchshun.github.io/tags/索引/"},{"name":"大表","slug":"大表","permalink":"http://latchshun.github.io/tags/大表/"}]},{"title":"关于Hive操作HBase报错can not get replica 0 location","slug":"关于HBase cannot get replica 0 location的报错","date":"2020-06-21T16:27:00.000Z","updated":"2020-06-21T17:14:02.363Z","comments":true,"path":"2020/06/22/关于HBase cannot get replica 0 location的报错/","link":"","permalink":"http://latchshun.github.io/2020/06/22/关于HBase cannot get replica 0 location的报错/","excerpt":"","text":"背景最近一直在忙于公司的标签系统项目，整个系统的硬件基础都基于阿里云。标签系统分为原生标签、即时标签、实时标签和离线标签，每日晚上会定时处理离线标签。最近接到业务的报错，说他的标签已经两天没数据产出且报错了，扔给了我个log的地址。一看，居然是报错Error while processing statement: FAILED: Execution Error, return code 1 from org.apache.hadoop.hive.ql.exec.mr.MapRedTask. Can’t get the location for replica 0。粗略看了下日志，没发现有什么问题，也想不明白哪里引起这个问题，遂上网查询一番。 –Error while processing statement: hive configuration hive.hadoop.supports.splittable.combineinputformat does not exists– 解决方法总结下网上搜索出的结果^1，大致分为三类： hbase中没有相关的表经排查，报错的标签对应的表是存在的，且有些标签是成功的。所以这种解决方法不适合。 hbase表错误执行hbase hbck命令^2检查是否有表错误。由于系统中有标签的成功，所以这种解决方法也不适合。 zookeeper连接错误 hive或者API或其他的方式连接HBase时，首先都要去连接HBase管理的zookeeper，从zookeeper中获取HBase的元数据信息，根据获取的元数据信息到指定的RegionServer里取值。如果zookeeper连接不上，那会报错can not get replica 0 location。经查询hive的日志，发现的确是zookeepr的原因，修改后解决。 追根溯源那zookeeper连接不上，为什么会报错can not get replica 0 location？这个报错又是什么意思呢？上面也解释了客户端读取HBase的流程：即首先都要去连接HBase管理的zookeeper，从zookeeper中获取HBase的元数据信息，根据获取的元数据信息到指定的RegionServer里取值。","categories":[],"tags":[{"name":"Hive","slug":"Hive","permalink":"http://latchshun.github.io/tags/Hive/"},{"name":"HBase","slug":"HBase","permalink":"http://latchshun.github.io/tags/HBase/"}]},{"title":"动态修改注解值","slug":"动态修改注解值","date":"2019-09-25T14:17:00.000Z","updated":"2019-10-20T14:53:06.376Z","comments":true,"path":"2019/09/25/动态修改注解值/","link":"","permalink":"http://latchshun.github.io/2019/09/25/动态修改注解值/","excerpt":"","text":"背景平时开发业务时，由于特殊需要，使得一份代码需要部署到4个应用服务中为不同对象进行服务。公司使用的配置中心是自研发的，暂不支持配置中心注解（如：@DynamicPropertyInject(name = &quot;${application.effective.exchanges}&quot;)）的值采用properties文件来动态配置。这使得在同套代码的不同应用场景下，表明同个含义的注入就需要声明多次，且有且仅只有一个声明对于当前应用是有效的。从简洁的角度来说不适合。 示例注解： 123456@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.FIELD&#125;public @interface DynamicPropertyInject &#123; String name() default '';&#125; 不能依据properties注入的代码情形： 12345678910public class DynamicConfiguration &#123; @DynamicPropertyInject(name = \"application1.effective.name\") private String application1ExchangeName; @DynamicPropertyInject(name = \"application2.effective.name\") private String application2ExchageName; @DynamicPropertyInject(name = \"application3.effective.name\") private String application3ExchangeName;&#125; 其实在每个应用中，仅只有application1ExchangeName或application2ExchangeName或application3ExchangeName其中之一有效。 能依据properties注入的代码情形： 1234public class DynamicConfiguration &#123; @DynamicPropertyInject(name = \"$&#123;application.effective.name&#125;\") private String applicationExchangeName;&#125; 解决：针对如上所述的场景，其实要解决的是来获取applicationExchangeName的时候，需要根据当前的应用名称来取其对应的值。很自然的，第一反应是通过反射来获取注解属性的值并修改之。 在这里提供下思路： 为DynamicConfiguration的类定义切面； 程序执行到注解DynamicPropertyInject时，判断是否需要去修改值。是则修改，否则跳过。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class DynamicConfigValueAspect &#123; public static final String CHARACTER_DOLLAR = \"$\"; public static final String CHARACTER_NUMBERSIGN = \"#\"; @Autowired private ApplicationProperties applicationProperties; @Around(\"this(package of DynamicConfiguration)\") public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; String methodName = pjp.getSignature().getName(); if (methodName.startsWith(\"get\") &amp;&amp; methodName.length() &gt;= 4) &#123; //提取属性名 String fieldName = methodName.substring(3, 4).toLowerCase() + methodName.substring(4); Field field = pjp.getTarget().getClass().getDeclaredField(fieldName); DynamicPropertyInject configuration = field.getAnnotation(DynamicPropertyInject.class); String configName = configuration.name(); //属性的DynamicPropertyInject注解值是否需要修改 if (StringUtils.isNotBlank(configName) &amp;&amp; StringUtils.startsWith(configName, CHARACTER_DOLLAR) || StringUtils.startsWith(configName, CHARACTER_NUMBERSIGN)) &#123; InvocationHandler invocationHandler = Proxy.getInvocationHandler(configuration); Field declaredField = invocationHandler.getClass().getDeclaredField(\"memberValues\"); declaredField.setAccessible(true); Map memberValues = (Map) declaredField.get(invocationHandler); //获取修改的值并修改 memberValues.put(\"name\", getApplicationPropertiesByConfigElement(configName)); &#125; &#125; return pjp.proceed(); &#125; //获取修改的值 private String getApplicationPropertiesByConfigElement(String configName) throws IllegalAccessException &#123; Field[] fields = ApplicationProperties.class.getDeclaredFields(); if (ArrayUtils.isEmpty(fields)) &#123; return null; &#125; for (Field field : fields) &#123; Value annotation = field.getAnnotation(Value.class); if (Objects.nonNull(annotation) &amp;&amp; StringUtils.equals(configName, annotation.value())) &#123; field.setAccessible(true); return String.valueOf(field.get(applicationProperties)); &#125; &#125; return null; &#125;&#125;//application property@Configurationpublic class ApplicationProperties &#123; @Value(\"$&#123;application.effective.name&#125;\") private String applicationEffectiveName;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://latchshun.github.io/tags/Java/"},{"name":"反射","slug":"反射","permalink":"http://latchshun.github.io/tags/反射/"},{"name":"注解","slug":"注解","permalink":"http://latchshun.github.io/tags/注解/"},{"name":"AOP","slug":"AOP","permalink":"http://latchshun.github.io/tags/AOP/"}]},{"title":"Redis Lua scripts debugger使用","slug":"redis_lua_debugger","date":"2019-09-11T11:50:00.000Z","updated":"2019-09-11T12:02:45.196Z","comments":true,"path":"2019/09/11/redis_lua_debugger/","link":"","permalink":"http://latchshun.github.io/2019/09/11/redis_lua_debugger/","excerpt":"","text":"背景说明使用Redis开发分布式应用时，难免会遇到需要使用分布式锁来确保某一小段逻辑的原子性操作，如：当存在某个key对应的值A大于值B时，则返回false；否则A + 1。试想一下，如果用到分布式锁，是不是有点感觉像是杀鸡用宰牛刀？ 由于Redis的操作都是原子性的，所以我们可以将如上所述的类似逻辑采用Lua脚本表述作为一个原子任务向redisClient提交，可以避免采用分布式锁。如脚本: 123456789101112131415161718192021local key = KEYS[1]local expire_time = tonumber(ARGV[1])local max_count = tonumber(ARGV[2])-- 验证key是否存在，不存在设置过期时间local is_key_exists = redis.call(\"EXISTS\", key)-- 存在if is_key_exists == 1 then local key_count = redis.call(\"get\", key) if tonumber(key_count) &gt;= max_count then return false; else redis.call(\"incr\", key) return true; endelse redis.call(\"incr\", key); redis.call(\"expire\", key, expire_time) return true;end 但此时发现，在Redis中调试是个困难的事情。但幸好，从Redis 3,2版本开始，提供了Lua script debugger来解决此问题。 Redis Lua调试器特点Redis Lua调试器代号为LDB，特点如下： 支持单步调试 支持静态和动态断点 支持将被调试的脚本载入至调试终端 支持对Lua变量进行观察 支持追踪脚本执行的Redis命令 支持以美观方式打印Redis值及Lua值 能够在无线循环及长时间执行步骤中模拟出断点 采用CS模型，S即Redis服务器，C即redis-cli客户端 默认情况下，每个调试会话都是fork子进程进行的。所以调试过程中不会影响Redis其他操作；调试结束后，本次会话中的内容都会被回滚 你也可以将调试会话设置成同步模式，但是此时必须注意调试时会影响Redis所有其他的操作，且调试会话产生的结果都会被保存下来 Redis Lua调试器快速入门想看视频的直接点这里，这是Redis之父录制的视频。 想看文字的继续。以我们在刚开始提供的Lua脚本，假设其目录为~/Desktop/tmp/test.lua。此时执行命令（需要先cd到redis-cli命令目录下）： 12345-- async moderedis-cli --ldb --eval redis_lua_file redis_key , param1 param2-- sync moderedis-cli --ldb-sync-mode --eval redis_lua_file redis_key , param1 param2 123456789 ~  redis-cli --ldb --eval ~/Desktop/tmp/test.lua key , 1 3Lua debugging session started, please use:quit -- End the session.restart -- Restart the script in debug mode again.help -- Show Lua script debugging commands.* Stopped at 6, stop reason = step over-&gt; 6 local key = KEYS[1]lua debugger&gt; 注意：redis-cli里的逗号前后都是有空格的。我这里示例是本地有开启redis-server，如果没有开启也可以连接到远程redis server进行调试。另外，key表示的是要传入脚本中处理的redis key，其后的1和3则是参数，中间用空格隔开。 之后所要做的就是在debugger里输入s命令回车，表示执行下一步，直至程序结束或有异常退出为止。 Redis Lua debug命令括号中字母代表命令缩写。 参考文章 Redis Lua scripts debugger","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://latchshun.github.io/tags/Redis/"},{"name":"Redis Lua scripts debugger","slug":"Redis-Lua-scripts-debugger","permalink":"http://latchshun.github.io/tags/Redis-Lua-scripts-debugger/"}]},{"title":"微服务基础架构图谱","slug":"微服务基础架构图谱","date":"2019-08-07T07:25:49.000Z","updated":"2019-08-07T09:12:21.893Z","comments":true,"path":"2019/08/07/微服务基础架构图谱/","link":"","permalink":"http://latchshun.github.io/2019/08/07/微服务基础架构图谱/","excerpt":"","text":"","categories":[],"tags":[{"name":"技术图谱","slug":"技术图谱","permalink":"http://latchshun.github.io/tags/技术图谱/"},{"name":"微服务","slug":"微服务","permalink":"http://latchshun.github.io/tags/微服务/"}]}]}